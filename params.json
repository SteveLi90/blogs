{
  "name": "Blogs",
  "tagline": "Sorting Algorithms",
  "body": "### Here is all of visualize [sorting](http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)\r\n\r\n# Bubble Sort\r\n\r\nBubble sort is easy, you just need to take the element from the beginning as a comparable element, and compare with the neighbor element next to it. If the neighbor element less than it, exchange the position, and compare with the next neighbor element. If the neighbor element greater than it,  take the neighbor element as the comparable element and compare with its neighbor. \r\n\r\n![bubble sort](http://mmbiz.qpic.cn/mmbiz/2A8tXicCG8ymuzP7hgSxdQNWOZWSLfCBNnSm1evBaXsiamEwprKLHE23j9qrqI3J36p3GbTO39Cic9BO3c0o97YyQ/0?tp=webp&wxfrom=5&wx_lazy=1)\r\n\r\n\r\nHere is the code written by python and ruby:\r\n\r\n**Python:**\r\n```python\r\ndef shortBubbleSort(alist):\r\n    exchanges = True\r\n    passNum = len(alist)-1\r\n    while passNum >0 and exchanges:\r\n        exchanges = False\r\n        for i in range(passNum):\r\n            if alist[i]>alist[i+1]:\r\n                exchanges = Ture\r\n                temp = alist[i]\r\n                alist[i] = alist[i+1]\r\n                alist[i+1] = temp\r\n        passNum -= 1\r\n```\r\n\r\n\r\n**ruby:**\r\n```ruby\r\ndef bubbleSort(arr)\r\n    n = arr.length\r\n    loop do\r\n        swapped = false\r\n        \r\n        (n-1).times do |i|\r\n            if arr[i] > arr[i+1]\r\n                arr[i], arr[i+1] = arr[i+1], arr[i]\r\n                swapped = true\r\n            end\r\n        end\r\n        \r\n        break if not swapped\r\n    end\r\n    return arr\r\nend\r\n\r\n\r\narr = Array.new(10000)\r\narr = 10000.times.map{0 + Random.rand(10000)}\r\narr = bubbleSort(arr)\r\nputs arr\r\n```\r\n\r\n# Selection Sort\r\n\r\nSelection sort just select the smallest or biggest element in the set, and exchange it with the serial order element or another empty set.\r\n\r\n![selection sort](http://mmbiz.qpic.cn/mmbiz/2A8tXicCG8ymuzP7hgSxdQNWOZWSLfCBNqZiaicWDc1JGYMU25eU49nicWkjWBr7iaPnORA6hpPz95H4sfWjQ7o0yoA/0?tp=webp&wxfrom=5&wx_lazy=1)\r\n\r\n**Python:**\r\n```python\r\ndef selectionSort(alist):\r\n    for i in range(len(alist)-1,0,-1):   # a loop for each position\r\n        posMax = 0\r\n        for loc in range(1,i+1):         # a sub loop to find the largest number\r\n            if alist[loc]>alist[posMax]:\r\n                posMax=loc\r\n\r\n        temp = alist[i]                  # exchange the number at current\r\n        alist[i] = alist[posMax]         # position and the largest number\r\n        alist[posMax] = temp\r\n```\r\n\r\n**Ruby**\r\n```ruby\r\ndef slct_sort (arr)\r\n    n = arr.length \r\n    (n).times do |j|\r\n        index = j\r\n        for i in j..n-1\r\n            if arr[i] < arr[index]\r\n                index = i\r\n            end   \r\n        end\r\n        arr[j], arr[index] = arr[index], arr[j]\r\n    end\r\n    return arr\r\nend\r\n\r\narr = Array.new(10000)\r\narr = 10000.times.map{0 + Random.rand(10000)}\r\narr = slct_sort(arr)\r\nputs arr\r\n```\r\n\r\n# insertion sort\r\nSuppose, you want to sort elements in ascending as in above figure. Then,\r\n\r\n* Step 1: The second element of an array is compared with the elements that appears before it (only first element in this case). If the second element is smaller than first element, second element is inserted in the position of first element. After first step, first two elements of an array will be sorted.\r\n* Step 2: The third element of an array is compared with the elements that appears before it (first and second element). If third element is smaller than first element, it is inserted in the position of first element. If third element is larger than first element but, smaller than second element, it is inserted in the position of second element. If third element is larger than both the elements, it is kept in the position as it is. After second step, first three elements of an array will be sorted.\r\n* Step 3: Similary, the fourth element of an array is compared with the elements that appears before it (first, second and third element) and the same procedure is applied and that element is inserted in the proper position. After third step, first four elements of an array will be sorted.\r\nIf there are n elements to be sorted. Then, this procedure is repeated n-1 times to get sorted list of array.\r\n\r\npython\r\n\r\n```python\r\ndef insertSort(alist):\r\n    for i in range(1,len(alist)):\r\n        curr = alist[i]\r\n        pos = i\r\n# compare the current number and the previous number\r\n        while pos >0 and alist[pos-1]> curr:\r\n            alist[pos] = alist[pos-1]\r\n            pos = pos-1\r\n# put the number in the right place\r\n        alist[pos]=curr\r\n```\r\n\r\nruby:\r\n\r\n```ruby\r\nclass Array\r\n  def insertionsort!\r\n    1.upto(length - 1) do |i|\r\n      value = self[i]\r\n      j = i - 1\r\n      while j >= 0 and self[j] > value\r\n        self[j+1] = self[j]\r\n        j -= 1\r\n      end\r\n      self[j+1] = value\r\n    end\r\n    self\r\n  end\r\nend\r\nary = [7,6,5,9,8,4,3,1,2,0]\r\np ary.insertionsort!\r\n# => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n```\r\n\r\n# Shell Sort\r\n\r\nThe shell sort, sometimes called the “diminishing increment sort,” improves on the insertion sort by breaking the original list into a number of smaller sublists, each of which is sorted using an insertion sort. The unique way that these sublists are chosen is the key to the shell sort. Instead of breaking the list into sublists of contiguous items, the shell sort uses an increment i, sometimes called the gap, to create a sublist by choosing all items that are i items apart.\r\n\r\n![shell sort](http://mmbiz.qpic.cn/mmbiz/2A8tXicCG8ymuzP7hgSxdQNWOZWSLfCBN2Y0sg8gyBBiaib2xicPaibFBMO4Z7Micq6P6mIWc3kBmNrJgJN8dGOibckFQ/0?tp=webp&wxfrom=5&wx_lazy=1)\r\n\r\npython\r\n\r\n```python\r\ndef shell(seq):\r\n    inc = len(seq) // 2\r\n    while inc:\r\n        for i, el in enumerate(seq):\r\n            while i >= inc and seq[i - inc] > el:\r\n                seq[i] = seq[i - inc]\r\n                i -= inc\r\n            seq[i] = el\r\n        inc = 1 if inc == 2 else int(inc * 5.0 / 11)\r\n \r\ndata = [22, 7, 2, -5, 8, 4]\r\nshell(data)\r\nprint data # [-5, 2, 4, 7, 8, 22]\r\n```\r\n\r\nruby:\r\n\r\n```ruby\r\nclass Array\r\n  def shellsort!\r\n    inc = length / 2\r\n    while inc != 0\r\n      inc.step(length-1) do |i|\r\n        el = self[i]\r\n        while i >= inc and self[i - inc] > el\r\n          self[i] = self[i - inc]\r\n          i -= inc\r\n        end\r\n        self[i] = el\r\n      end\r\n      inc = (inc == 2 ? 1 : (inc * 5.0 / 11).to_i)\r\n    end\r\n    self\r\n  end\r\nend\r\n \r\ndata = [22, 7, 2, -5, 8, 4]\r\ndata.shellsort!\r\np data # [-5, 2, 4, 7, 8, 22]\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}